package main

import "gproject/solution"

func main() {
	// longUrl := "https://leetcode.com/problems/design-tinyurl"
	// obj := solution.Constructor()
	// url := obj.Encode(longUrl)
	// ans := obj.Decode(url)
	// fmt.Println(ans)

	// s := "abcdefg"
	// s1 := solution.ReverseStr(s, 2)
	// fmt.Println(s1)

	//fmt.Println(solution.NumPrimeArrangements(100))

	// fmt.Println(solution.DiffWaysToCompute("2*3-4*5"))
	//nums := []int {2, 3, 1, 0, 2, 5, ?
	//solution.Test()
	//fmt.Println(solution.MinimumDeleteSum("delete", "leet"))
	//fmt.Println(solution.MinimumDeleteSum("sea", "eat"))
	//fmt.Println(solution.LengthOfLIS?int {7, 7, 7, 7, 7, 7, 7, 7}))
	//res := solution.AsteroidCollision([]int {5, 10, -5})
	//fmt.Println(len(res))
	//for i := range res {
	//	fmt.Println(i)
	//}

	//res := solution.MaxEqualFreq([]int {2, 2, 1, 1, 5, 3, 3, 5})
	//fmt.Println(res)
	//res := solution.MaxEqualFreq([]int {1,1,1,2,2,2,3,3,3,4,4,4,5})
	//print(res)
	//print(solution.MakeLargestSpecial("11011000"))

	//arr := []int {1,1,1,10,10,10}
	//res := solution.FindClosestElements(arr, 1, 9)
	//for i := 0; i < len(res); i++ {
	//	fmt.Print(res[i])
	//}

	//nums := []int {3, 4, 5, 2}
	//nums := []int {1, 5, 4, 5}
	//print(solution.MaxProduct(nums))
	//pushed := []int {1, 2, 3, 4, 5}
	//popped := []int {4, 5, 3, 2, 1}
	//popped := []int {4, 3, 5, 1, 2}
	//fmt.Println(solution.ValidateStackSequences(pushed, popped))
	//answer := solution.ConstructArray(3, 2)
	//for _, v := range answer {
	//	fmt.Println(v)
	//}
	//nums := []int {3, 1, 5, 8}
	//nums := []int {1, 5}
	//fmt.Println(solution.MaxCoins(nums))
	//matrix := [][]int {{7, 8, 9}, {9, 7, 6}, {7, 2, 3}}
	//print(solution.LongestIncreasingPath(matrix))
	//nums := []int {1, 3}
	//nums := []int {1, 5, 10}
	//nums := []int {1, 2, 2}
	//print(solution.MinPatches(nums, 5))
	//a := solution.ListNode{1ï¼Œ nil}
	//res := solution.MergeInBetween()

	//n := 3
	//redEdges := [][]int {{0, 1}, {1, 2}}
	//blueEdges := [][]int{{}}
	//res := solution.ShortestAlternatingPaths(n, redEdges, blueEdges)
	//for i := range res {
	//    fmt.Println(i)
	//}
	//folder := []string {"/a", "/a/b", "/c/d", "/c/d/e", "/c/f"}
	//solution.QuickSort(folder, 0, 4)
	//for _, v := range folder {
	//    fmt.Println(v)
	//}

	//Obj := solution.Constructor1797(5)
	//Obj.Renew("aaa", 1)
	//Obj.Generate("aaa", 2)
	//print(Obj.CountUnexpiredTokens(6))
	//Obj.Generate("bbb", 7)
	//Obj.Renew("aaa", 8)
	//Obj.Renew("bbb", 10)
	//print(Obj.CountUnexpiredTokens(15))
	//var a int
	//a = 5
	//fmt.Println(a)
	//nums := []int {1, 3,2,1,3,2,2}
	//nums := []int {1,1}
	//nums := []int pil
	//piles := []int {2,7,9,4,4}
	//print(solution.StoneGameII(piles))
	//print(math.MaxInt)
	//res := solprin
	//time.AfterFunc()
	//print(solution.CalTwo(16))
	//nums := []int {1, 5, 0, 3, 5}
	//print(solution.MinimumOperations(nums))
	//nums := []int {1,2,3}
	//nums := []int {9,6,1,6,2}
	//print(solution.MovesToMakeZigZag(nums))
	//arr := []int {1,3,4}
	//arr1 := arr
	//arr2 := &arr
	//fmt.Println(arr1)
	//fmt.Println(arr2)
	//arr[0] = 2
	//fmt.Println(arr1)
	//fmt.Println(arr2)
	//items1 := [][]int {{1, 1}, {4, 5}, {3, 8}}
	//items2 := [][]int {{3, 1}, {1, 5}}
	//fmt.Println(solution.MergeSimilarItems(items1, items2))
	//grid := [][]int {{9,9,8,1}, {5,6,2,6}, {8,2,6,4},{6,2,2,2}}
	//fmt.Println(solution.LargestLocal(grid))
	//fmt.Println(solution.PrintBin(0.8125))
	//fmt.Println(solution.PrintBin(0.625))
	//fmt.Println(solution.PrintBin(0.1))
	//fmt.Println((-1)/(-2))
	//fmt.Println((19)/(-2))
	//fmt.Println(solution.BaseNeg2(19))
	//fmt.Println(solution.BaseNeg2(2))
	//fmt.Println(solution.BaseNeg2(3))
	//fmt.Println(solution.BaseNeg2(4))
	//s := "9,3,4,#,#,1,#,#,2,#,6,#,#"
	//s := "1, #"
	//s := "9, #, #, 1"
	////s := "9,#,92,#,#"
	//fmt.Println(solution.IncreasingTriplet([]int {1,2,3,4,5}))
	//fmt.Println(solution.IncreasingTriplet([]int {5,4,3,2,1}))
	//fmt.Println(solution.IncreasingTriplet([]int {2,1,5,0,4,6}))
	//fmt.Println(solution.IncreasingTriplet([]int {0,4,2,1,0,-1,-3}))
	//node5 := datastructure.ListNode{5, nil}
	//node4 := datastructure.ListNode{3, &node5}
	//node3 := datastructure.ListNode{4, &node4}
	//node2 := datastructure.ListNode{7, &node3}
	//node1 := datastructure.ListNode{2, &node2}
	//res := solution.NextLargerNodes(&node1)
	//for _, v := range res {
	//	fmt.Println(v)
	//}
	//fmt.Println(solution.IsRobotBounded("GGLLGG"))
	//fmt.Println(solution.IsRobotBounded("GG"))
	//fmt.Println(solution.IsRobotBounded("GL"))
	//fmt.Println(solution.MostFrequentEven([]int {0, 1, 2,2,4,4,1}))
	//fmt.Println(solution.MostFrequentEven([]int {0, 0,0,0}))
	//fmt.Println((0%2))
	//queires := []string{"FooBar", "FooBarTest", "FootBall", "FrameBuffer", "ForceFeedBack"}
	//queires := []string{"FooBar", "FooBarTest", "FootBall", "FrameBuffer", "ForceFeedBack"}
	//pattern := "FoBaT"
	//fmt.Println(solution.CamelMatch(queires, pattern))
	//fmt.Println(solution.CountDaysTogether("08-15", "08-18", "08-16", "08-19"))
	//fmt.Println(solution.CountDaysTogether("10-01", "10-31", "11-01", "12-31"))
	//fmt.Println(solution.CountDaysTogether("10-01", "10-31", "10-31", "12-31"))
	//arr := []int{1, 15, 7, 9, 2, 5, 10}
	//k := 3
	//arr := []int{1, 4, 1, 5, 7, 3, 6, 1, 9, 9, 3}
	//k := 4
	//arr := []int{1}
	//k := 1
	//fmt.Print(solution.MaxSumAfterPartitioning(arr, k))

	//arr1 := []int{1, 5, 3, 6, 7}
	//arr2 := []int{1, 3, 2, 4}
	//arr2 := []int{4, 3, 1}
	//arr2 := []int{1, 6, 3, 3}
	//fmt.Print(solution.MakeArrayIncreasing(arr1, arr2))

	//n := solution.SmallestEventMultiple(6)
	//print(n)
	//books := [][]int{{1, 1}, {2, 3}, {2, 3}, {1, 1}, {1, 1}, {1, 1}, {1, 2}}
	//shelfWidth := 4
	//books := [][]int{{1, 3}, {2, 4}, {3, 2}}
	//shelfWidth := 6
	//fmt.Print(solution.MinHeightShelves(books, shelfWidth))
	//words := []string{"a", "b", "ba", "bca", "bda", "bdca"}
	//words := []string{"xbc", "pcxbcf", "xb", "cxbc", "pcxbc"}
	//words := []string{"abcd", "bdqca"}
	//fmt.Println(solution.LongestStrChain(words))
	//fmt.Println(solution.HardestWorker(10, [][]int{{0, 3}, {2, 5}, {0, 9}, {1, 15}}))
	//fmt.Println(solution.HardestWorker(26, [][]int{{1, 1}, {3, 7}, {2, 12}, {7, 17}}))
	//fmt.Println(solution.HardestWorker(2, [][]int{{0, 10}, {1, 20}}))
	//println(solution.CountTime("?5:00"))
	//println(solution.CountTime("0?:0?"))
	//println(solution.CountTime("??:??"))
	//println(solution.CountTime("?4:22"))
	//println(solution.CountTime("07:?3"))
	//println(solution.CountTime("?9:?0"))
	//fmt.Println(solution.QueryString("0110", 3))
	//fmt.Println(solution.QueryString("0110", 4))
	//fmt.Println(solution.QueryString("1", 1))
	//fmt.Println(solution.QueryString("0101011001101101010001001111110111100110110001001111001111111011010010101001011111010010001011011011", 5))
	//fmt.Println(solution.IntegerBreak(2))
	//a := []int{3, 6, 7, 11}
	//a := []int{30, 11, 23, 4, 20}
	//a := []int{3, 6, 7, 11}
	//fmt.Println(solution.MinEatingSpeed(a, 6))
	//nums := [][]int{{3, 2, 1}, {1, 7, 6}, {2, 7, 7}}
	//nums := [][]int{{3, 1, 2, 2}, {1, 4, 4, 5}, {2, 4, 2, 2}, {2, 4, 2, 2}}
	//nums := [][]int{{3, 1, 2, 2}, {1, 4, 4, 5}, {2, 4, 2, 2}, {2, 4, 2, 2}}
	//nums := [][]int{{11, 1}, {1, 11}}
	//res := solution.EqualPairs(nums)
	//fmt.Println(res)
	//nums := []int{1, 2, 5, 9}
	//t := 6
	//nums := []int{2, 3, 5, 7, 11}
	//t := 11
	//nums := []int{19}
	//t := 5
	//fmt.Println(solution.SmallestDivisor(nums, t))
	//nums1 := []int{1, 1, 3, 4}
	//nums2 := []int{4, 4, 1, 1}
	//fmt.Println(solution.MiceAndCheese(nums1, nums2, 2))
	//time := []int{1, 2, 3}
	//totalTrips := 5
	//time := []int{1}
	//totalTrips := 1
	//time := []int{2}
	//totalTrips := 1
	//fmt.Println(solution.MinimumTime(time, totalTrips))
	//candies := []int{5, 8, 6}
	//k := 3
	//candies := []int{2, 5}
	//k := 11
	//fmt.Println(solution.MaximumCandies(candies, int64(k)))
	//dist := []int{1, 3, 2}
	//hour := 6
	//hour := 2.7
	//hour := 1.9
	//dist := []int{1, 1, 100000}
	//hour := 2.01
	//  10000000
	//fmt.Println(solution.MinSpeedOnTime(dist, float64(hour)))
	//weights := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	//days := 5
	//weights := []int{3, 2, 2, 4, 1, 4}
	//days := 3
	//weights := []int{1, 2, 3, 1, 1}
	//days := 4
	//fmt.Println(solution.ShipWithinDays(weights, days))
	//nums := []int{9}
	//maxOperations := 2
	//nums := []int{2, 4, 8, 2}
	//maxOperations := 4
	//println(solution.MinimumSize(nums, maxOperations))
	//bloomDay := []int{1, 10, 3, 10, 2}
	//m := 3
	//k := 1
	//bloomDay := []int{7, 7, 7, 7, 12, 7, 7}
	//m := 2
	//k := 3
	//bloomDay := []int{1, 10, 3, 10, 2}
	//m := 3
	//k := 2
	//bloomDay := []int{5, 37, 55, 92, 22, 52, 31, 62, 99, 64, 92, 53, 34, 84, 93, 50, 28}
	//m := 8
	//k := 2
	//fmt.Println(solution.MinDays(bloomDay, m, k))
	//i := 1
	//i := 2
	//fmt.Println(i)
	//fmt.Println(i)
	//nums := []int{4, 4, 2, 4, 3}
	//nums := []int{1, 1, 1, 1, 1}
	//fmt.Println(solution.UnequalTriplets(nums))
	//solution.TestHeap()
	//heights := []int{4, 2, 7, 6, 9, 14, 12}
	//bricks := 5
	//ladders := 1
	//heights := []int{4, 12, 2, 7, 3, 18, 20, 3, 19}
	//bricks := 10
	//ladders := 2
	//heights := []int{14, 3, 19, 3}
	//bricks := 17
	//ladders := 0
	//fmt.Println(solution.FurthestBuilding(heights, bricks, ladders))
	//fmt.Println('c' - 'a')
	//s := "abcda"
	//queries := [][]int{{3, 3, 0}, {1, 2, 0}, {0, 3, 1}, {0, 3, 2}, {0, 4, 1}}
	//res := solution.CanMakePaliQueries(s, queries)
	//fmt.Println(res)
	//solution.Test0373()
	//solution.Test1262()
	//solution.Test0719()
	//solution.Test1508()
	//solution.Test1590()
	//solution.Test0523()
	//solution.Test0525()
	//a := 1
	//t1(&a)
	//fmt.Println(a)
	//solution.Test1020()
	//solution.Test0695()
	//solution.Test1253()
	//solution.Test0463()
	//solution.Test035202()
	//solution.Test0445()
	//fmt.Println(10/10)
	//solution.Test2679()
	//solution.Test2600()
	//solution.Test02178()
	//solution.Test0934()
	//solution.Test0994()
	//solution.Test35301()
	//solution.T35302()
	//solution.Test0934()
	//solution.Test0016()
	//solution.Test1911()
	//solution.Test1162()
	//solution.Test0931()
	solution.Test979()
}

//func t1(a *int) {
//	*a = 2
//}
